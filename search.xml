<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django REST framework]]></title>
    <url>%2Fpost%2Fdjango%20rest%20framework%20%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[django rest framework 项目使用目的：提供前后端分离的架构模式。 1.提供了定义序列化器Serializer的方法,可以快速根据Django ORM 或者其他库自动序列化/反序列化2.提供了丰富的类视图扩展类,简化视图的编写3.丰富的定制层级:函数视图\类视图\结合到自动生成API,满足各种需要4.多种身份认证和权限认证方式的支持5.直观的API web界面 安装依赖包 12345678910111213pip install djangorestframeworkpip install djangopip install markdownpip install django-filterpip install pillowpip install pymysqlpip install mysqlclient 建立超级用户1python manage.py createsuperuser --email admin@163.com --username admin Django 项目 settings.py添加 1234INSTALLED_APPS = ( ... 'rest_framework',) Django 项目urls.py添加1234urlpatterns = [ ... url(r&apos;^api-auth/&apos;, include(&apos;rest_framework.urls&apos;))] 创建项目和app 123456789django-admin startproject shoppython manage.py startapp userspython manage.py startapp goodspython manage.py startapp tradepython manage.py startapp user_operation 配置数据库连接 settings.py 1234567891011121314DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;shop&apos;, #数据库名字 &apos;USER&apos;: &apos;root&apos;, #账号 &apos;PASSWORD&apos;: &apos;Vff123456&apos;, #密码 &apos;HOST&apos;: &apos;127.0.0.1&apos;, #IP &apos;PORT&apos;: &apos;3306&apos;, #端口 #这里引擎用innodb（默认myisam） #因为后面第三方登录时，要求引擎为INNODB # &apos;OPTIONS&apos;:&#123;&apos;init_command&apos;: &apos;SET storage_engine=INNODB&apos;&#125;, #这样设置会报错，改为 &quot;OPTIONS&quot;:&#123;&quot;init_command&quot;:&quot;SET default_storage_engine=INNODB;&quot;&#125; &#125;&#125; init.py添加代码： 12import pymysqlpymysql.install_as_MySQLdb() users model 设计 12345678910111213141516171819202122232425262728293031323334353637383940414243# users/models.pyfrom datetime import datetimefrom django.db import modelsfrom django.contrib.auth.models import AbstractUserclass UserProfile(AbstractUser): &quot;&quot;&quot; 用户信息 &quot;&quot;&quot; GENDER_CHOICES = ( (&quot;male&quot;, u&quot;男&quot;), (&quot;female&quot;, u&quot;女&quot;) ) #用户用手机注册，所以姓名，生日和邮箱可以为空 name = models.CharField(&quot;姓名&quot;,max_length=30, null=True, blank=True) birthday = models.DateField(&quot;出生年月&quot;,null=True, blank=True) gender = models.CharField(&quot;性别&quot;,max_length=6, choices=GENDER_CHOICES, default=&quot;female&quot;) mobile = models.CharField(&quot;电话&quot;,max_length=11) email = models.EmailField(&quot;邮箱&quot;,max_length=100, null=True, blank=True) class Meta: verbose_name = &quot;用户信息&quot; verbose_name_plural = verbose_name def __str__(self): return self.usernameclass VerifyCode(models.Model): &quot;&quot;&quot; 验证码 &quot;&quot;&quot; code = models.CharField(&quot;验证码&quot;,max_length=10) mobile = models.CharField(&quot;电话&quot;,max_length=11) add_time = models.DateTimeField(&quot;添加时间&quot;,default=datetime.now) class Meta: verbose_name = &quot;短信验证&quot; verbose_name_plural = verbose_name def __str__(self): return self.code 替换系统的用户，还要在settings中配置 1234#settings.py#重载系统的用户，让UserProfile生效AUTH_USER_MODEL = &apos;users.UserProfile&apos; 设置media保存路径 123# 设置上传文件的路径MEDIA_URL = &quot;/media/&quot;MEDIA_ROOT = os.path.join(BASE_DIR,&quot;media&quot;) goods model 设计 商品分类model 设计 123456789101112131415161718192021222324252627class GoodsCategory(models.Model): """ 商品分类 """ CATEGORY_TYPE = ( (1, "一级类目"), (2, "二级类目"), (3, "三级类目"), ) name = models.CharField('类别名',default="", max_length=30,help_text="类别名") code = models.CharField("类别code",default="", max_length=30,help_text="类别code") desc = models.TextField("类别描述",default="",help_text="类别描述") #目录树级别 category_type = models.IntegerField("类目级别",choices=CATEGORY_TYPE,help_text="类目级别") # 设置models有一个指向自己的外键 parent_category = models.ForeignKey("self", on_delete=models.CASCADE, null=True, blank=True, verbose_name="父类目级别", help_text="父目录", related_name="sub_cat") is_tab = models.BooleanField("是否导航",default=False,help_text="是否导航") add_time = models.DateTimeField("添加时间",default=datetime.now) class Meta: verbose_name = "商品类别" verbose_name_plural = verbose_name def __str__(self): return self.name 商品model设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Goods(models.Model): """ 商品 """ category = models.ForeignKey(GoodsCategory, on_delete=models.CASCADE, verbose_name="商品类目") goods_sn = models.CharField("商品唯一货号",max_length=50, default="") name = models.CharField("商品名",max_length=100,) click_num = models.IntegerField("点击数",default=0) sold_num = models.IntegerField("商品销售量",default=0) fav_num = models.IntegerField("收藏数",default=0) goods_num = models.IntegerField("库存数",default=0) market_price = models.FloatField("市场价格",default=0) shop_price = models.FloatField("本店价格",default=0) goods_brief = models.TextField("商品简短描述",max_length=500) ship_free = models.BooleanField("是否承担运费",default=True) # 首页中展示的商品封面图 goods_front_image = models.ImageField(upload_to="goods/images/", null=True, blank=True, verbose_name="封面图") # 首页中新品展示 is_new = models.BooleanField("是否新品",default=False) # 商品详情页的热卖商品，自行设置 is_hot = models.BooleanField("是否热销",default=False) add_time = models.DateTimeField("添加时间",default=datetime.now) class Meta: verbose_name = '商品信息' verbose_name_plural = verbose_name def __str__(self): return self.nameclass GoodsImage(models.Model): """ 商品轮播图 """ goods = models.ForeignKey(Goods, on_delete=models.CASCADE, verbose_name="商品", related_name="images") image = models.ImageField(upload_to="", verbose_name="图片", null=True, blank=True) add_time = models.DateTimeField("添加时间", default=datetime.now) class Meta: verbose_name = '商品轮播' verbose_name_plural = verbose_name def __str__(self): return self.goods.name 首页商品轮播图model设计 123456789101112131415class Banner(models.Model): &quot;&quot;&quot; 首页轮播的商品 &quot;&quot;&quot; goods = models.ForeignKey(Goods, on_delete=models.CASCADE, verbose_name=&quot;商品&quot;) image = models.ImageField(upload_to=&apos;banner&apos;, verbose_name=&quot;轮播图片&quot;) index = models.IntegerField(&quot;轮播顺序&quot;,default=0) add_time = models.DateTimeField(&quot;添加时间&quot;, default=datetime.now) class Meta: verbose_name = &apos;首页轮播&apos; verbose_name_plural = verbose_name def __str__(self): return self.goods.name 商品广告和热搜model 1234567891011121314class HotSearchWords(models.Model): """ 搜索栏下方热搜词 """ keywords = models.CharField("热搜词",default="", max_length=20) index = models.IntegerField("排序",default=0) add_time = models.DateTimeField("添加时间", default=datetime.now) class Meta: verbose_name = '热搜排行' verbose_name_plural = verbose_name def __str__(self): return self.keywords 交易的model设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# trade/models.pyfrom datetime import datetimefrom django.db import modelsfrom goods.models import Goods# get_user_model方法会去setting中找AUTH_USER_MODELfrom django.contrib.auth import get_user_modelUser = get_user_model()# Create your models here.class ShoppingCart(models.Model): """ 购物车 """ user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name="用户") goods = models.ForeignKey(Goods, on_delete=models.CASCADE, verbose_name="商品") nums = models.IntegerField("购买数量",default=0) add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = '购物车' verbose_name_plural = verbose_name unique_together = ("user", "goods") def __str__(self): return "%s(%d)".format(self.goods.name, self.nums)class OrderInfo(models.Model): """ 订单信息 """ ORDER_STATUS = ( ("TRADE_SUCCESS", "成功"), ("TRADE_CLOSED", "超时关闭"), ("WAIT_BUYER_PAY", "交易创建"), ("TRADE_FINISHED", "交易结束"), ("paying", "待支付"), ) PAY_TYPE = ( ("alipay", "支付宝"), ("wechat", "微信"), ) user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name="用户") #订单号唯一 order_sn = models.CharField("订单编号",max_length=30, null=True, blank=True, unique=True) # 微信支付会用到 nonce_str = models.CharField("随机加密串",max_length=50, null=True, blank=True, unique=True) # 支付宝交易号 trade_no = models.CharField("交易号",max_length=100, unique=True, null=True, blank=True) #支付状态 pay_status = models.CharField("订单状态",choices=ORDER_STATUS, default="paying", max_length=30) # 订单的支付类型 pay_type = models.CharField("支付类型",choices=PAY_TYPE, default="alipay", max_length=10) post_script = models.CharField("订单留言",max_length=200) order_mount = models.FloatField("订单金额",default=0.0) pay_time = models.DateTimeField("支付时间",null=True, blank=True) # 用户信息 address = models.CharField("收货地址",max_length=100, default="") signer_name = models.CharField("签收人",max_length=20, default="") singer_mobile = models.CharField("联系电话",max_length=11) add_time = models.DateTimeField("添加时间",default=datetime.now) class Meta: verbose_name = "订单信息" verbose_name_plural = verbose_name def __str__(self): return str(self.order_sn)class OrderGoods(models.Model): """ 订单内的商品详情 """ # 一个订单对应多个商品 order = models.ForeignKey(OrderInfo, on_delete=models.CASCADE, verbose_name="订单信息", related_name="goods") # 两个外键形成一张关联表 goods = models.ForeignKey(Goods, on_delete=models.CASCADE, verbose_name="商品") goods_num = models.IntegerField("商品数量",default=0) add_time = models.DateTimeField("添加时间",default=datetime.now) class Meta: verbose_name = "订单商品" verbose_name_plural = verbose_name def __str__(self): return str(self.order.order_sn) 用户操作的model设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# user_operation/models.pyfrom datetime import datetimefrom django.db import modelsfrom goods.models import Goodsfrom django.contrib.auth import get_user_modelUser = get_user_model()class UserFav(models.Model): """ 用户收藏操作 """ user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name="用户") goods = models.ForeignKey(Goods, on_delete=models.CASCADE, verbose_name="商品", help_text="商品id") add_time = models.DateTimeField("添加时间",default=datetime.now) class Meta: verbose_name = '用户收藏' verbose_name_plural = verbose_name unique_together = ("user", "goods") def __str__(self): return self.user.usernameclass UserAddress(models.Model): """ 用户收货地址 """ user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name="用户" ) province = models.CharField("省份",max_length=100, default="") city = models.CharField("城市",max_length=100, default="") district = models.CharField("区域",max_length=100, default="") address = models.CharField("详细地址",max_length=100, default="") signer_name = models.CharField("签收人",max_length=100, default="") signer_mobile = models.CharField("电话",max_length=11, default="") add_time = models.DateTimeField("添加时间",default=datetime.now) class Meta: verbose_name = "收货地址" verbose_name_plural = verbose_name def __str__(self): return self.addressclass UserLeavingMessage(models.Model): """ 用户留言 """ MESSAGE_CHOICES = ( (1, "留言"), (2, "投诉"), (3, "询问"), (4, "售后"), (5, "求购") ) user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name="用户") message_type = models.IntegerField(default=1, choices=MESSAGE_CHOICES, verbose_name="留言类型", help_text=u"留言类型: 1(留言),2(投诉),3(询问),4(售后),5(求购)") subject = models.CharField("主题",max_length=100, default="") message = models.TextField("留言内容",default="",help_text="留言内容") file = models.FileField(upload_to="message/images/", verbose_name="上传的文件", help_text="上传的文件") add_time = models.DateTimeField("添加时间",default=datetime.now) class Meta: verbose_name = "用户留言" verbose_name_plural = verbose_name def __str__(self): return self.subject 12python manage.py makemigrationspython manage.py migrate 商品列表页APIview方式实现商品列表页安装 12pip install coreapi # drf的文档支持pip install django-guardian # drf对象级别的权限支持 配置drf文档的url shop/urls.py 123456from rest_framework.documentation import include_docs_urlsurlpatterns = [ #drf文档，title自定义 path('docs',include_docs_urls(title='shop api文档')),] 配置rest_framework settings.py中添加 123INSTALLED_APPS = [ 'rest_framework',] 123urlpatterns = [ path('api-auth/',include('rest_framework.urls')),] goods文件夹下面新建serializers.py 用drf的序列化实现商品列表页展示，代码如下 12345678# goods/serializers.pyfrom rest_framework import serializers class GoodsSerializer(serializers.Serializer): name = serializers.CharField(required=True,max_length=100) click_num = serializers.IntegerField(default=0) goods_front_image = serializers.ImageField() goods/views.py 12345678910111213from rest_framework.views import APIViewfrom goods.serializers import GoodsSerializerfrom .models import Goodsfrom rest_framework.response import Responseclass GoodsListView(APIView): ''' 商品列表 ''' def get(self,request,format=None): goods = Goods.objects.all() goods_serialzer = GoodsSerializer(goods,many=True) return Response(goods_serialzer.data) drf的Modelserializer实现商品列表页上面是用Serializer实现的，需要自己手动添加字段，如果用Modelserializer，会更加的方便，直接用all就可以全部序列化 12345678910111213141516# goods/serializers.pyfrom rest_framework import serializersfrom .models import Goods#Serializer实现商品列表页# class GoodsSerializer(serializers.Serializer):# name = serializers.CharField(required=True,max_length=100)# click_num = serializers.IntegerField(default=0)# goods_front_image = serializers.ImageField()#ModelSerializer实现商品列表页class GoodsSerializer(serializers.ModelSerializer): class Meta: model = Goods fields = '__all__' Serialzer还可以嵌套使用，覆盖外键字段 12345678910111213141516171819202122232425# goods/serializers.pyfrom rest_framework import serializersfrom .models import Goods,GoodsCategory#Serializer实现商品列表页# class GoodsSerializer(serializers.Serializer):# name = serializers.CharField(required=True,max_length=100)# click_num = serializers.IntegerField(default=0)# goods_front_image = serializers.ImageField()class CategorySerializer(serializers.ModelSerializer): class Meta: model = GoodsCategory fields = "__all__"#ModelSerializer实现商品列表页class GoodsSerializer(serializers.ModelSerializer): #覆盖外键字段 category = CategorySerializer() class Meta: model = Goods fields = '__all__' GenericAPIView继承APIView，封装了很多方法，比APIView功能更强大 ListModelMixin里面list方法帮我们做好了分页和序列化的工作 ListAPIView(mixins.ListModelMixin,GenericAPIView) 继承了这两个类 写好了get方法，可以简化工作 1234567from rest_framework import mixinsfrom rest_framework import genericsclass GoodsListView(generics.ListAPIView): '商品列表页' queryset = Goods.objects.all() serializer_class = GoodsSerializer 添加分页功能，配置如下： 123456REST_FRAMEWORK = &#123; #分页 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', #每页显示的个数 'PAGE_SIZE': 10,&#125; http://127.0.0.1:8000/goods/?page=2 自定义分页功能 12345678910111213141516171819202122from rest_framework.pagination import PageNumberPaginationclass GoodsPagination(PageNumberPagination): ''' 商品列表自定义分页 ''' #默认每页显示的个数 page_size = 5 #可以动态改变每页显示的个数 page_size_query_param = 'page_size' #页码参数 page_query_param = 'page' #最多能显示多少页 max_page_size = 100class GoodsListView(generics.ListAPIView): '商品列表页' pagination_class = GoodsPagination #分页 queryset = Goods.objects.all() serializer_class = GoodsSerializer settings.py里面就不用设置了 viewsets和router完成商品列表页ViewSets和Routers结合使用 urls.py 123456789101112from django.conf.urls import url, includefrom goods.views import GoodsListViewSetfrom rest_framework.routers import DefaultRouterrouter = DefaultRouter()router.register(r'goods', GoodsListViewSet)# Wire up our API using automatic URL routing.# Additionally, we include login URLs for the browsable API.urlpatterns = [ url(r'^', include(router.urls)),] views.py 12345678class GoodsListViewSet(mixins.ListModelMixin,viewsets.GenericViewSet): '商品列表页' # 分页 pagination_class = GoodsPagination #这里必须要定义一个默认的排序,否则会报错 queryset = Goods.objects.all().order_by('id') serializer_class = GoodsSerializer GenericViewSet（viewsets） —-drf GenericAPIView —drf APIView —drf View —-django 这些view功能的不同，主要的是有mixin的存在 mixins总共有五种： CreateModelMixin ListModelMixin UpdateModelMixin RetrieveModelMixin DestoryModelMixin drf的request和response介绍request.data 返回请求主题的解析内容 包括所有解析的内容，文件（file） 和 非文件（non-file inputs）。 支持解析 POST 以外的 HTTP method ， 比如 PUT， PATCH。 更加灵活，不仅仅支持表单数据，传入同样的 JSON 数据一样可以正确解析，并且不用做额外的处理（意思是前端不管提交的是表单数据，还是 JSON 数据，.data 都能够正确解析）。 request.query_params等同于request.GET response 由于 Response 类使用的渲染器不能处理复杂的数据类型（比如 Django 的模型实例），所以需要在创建 Response 对象之前将数据序列化为基本的数据类型。 drf的过滤添加到app里面 123INSTALLED_APPS = [ 'django_filters',] 新建filter.py 123456789101112131415161718# goods/filters.pyimport django_filtersfrom .models import Goodsclass GoodsFilter(django_filters.rest_framework.FilterSet): ''' 商品过滤的类 ''' #两个参数，name是要过滤的字段，lookup是执行的行为，‘小与等于本店价格’ price_min = django_filters.NumberFilter(field_name="shop_price", lookup_expr='gte') price_max = django_filters.NumberFilter(field_name="shop_price", lookup_expr='lte') class Meta: model = Goods fields = ['price_min', 'price_max'] views.py 12345678910111213141516171819from .filters import GoodsFilterfrom django_filters.rest_framework import DjangoFilterBackendfrom rest_framework import status, mixins, generics, viewsets,filtersclass GoodsListViewSet(mixins.ListModelMixin,viewsets.GenericViewSet): '商品列表页' #这里必须要定义一个默认的排序,否则会报错 queryset = Goods.objects.all().order_by('id') # 分页 pagination_class = GoodsPagination serializer_class = GoodsSerializer filter_backends = (DjangoFilterBackend,filters.SearchFilter) # 设置filter的类为我们自定义的类 filter_class = GoodsFilter #搜索,=name表示精确搜索，也可以使用各种正则表达式 search_fields = ('=name','goods_brief') http://127.0.0.1:8000/goods/?page=1&amp;price_min=50&amp;price_max=70 添加排序功能 123456789101112131415161718class GoodsListViewSet(mixins.ListModelMixin,viewsets.GenericViewSet): '商品列表页' #这里必须要定义一个默认的排序,否则会报错 queryset = Goods.objects.all() # 分页 pagination_class = GoodsPagination #序列化 serializer_class = GoodsSerializer filter_backends = (DjangoFilterBackend,filters.SearchFilter,filters.OrderingFilter) # 设置filter的类为我们自定义的类 #过滤 filter_class = GoodsFilter #搜索,=name表示精确搜索，也可以使用各种正则表达式 search_fields = ('=name','goods_brief') #排序 ordering_fields = ('sold_num', 'add_time') http://127.0.0.1:8000/goods/?ordering=sold_num&amp;page=2 http://127.0.0.1:8000/goods/?ordering=-sold_num&amp;page=2]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django基础]]></title>
    <url>%2Fpost%2FDjango%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[ORM（objects relationship mapping）：对象关系映射(将models中的函数转换成数据库语句) 实现插入数据在views.py中定义函数 123456789101112def add_stu(request): # 实现插入数据 #第一种方法 # Student.objects.create(s_name=&apos;小明&apos;) # 第二种方法 stu = Student() stu.s_name = &apos;小花1&apos; stu.s_gender = 1 stu.save() return HttpResponse(&apos;创建学生成功&apos;) 实现删除数据123456def del_stu(request): #实现删除 #1.获取删除的对象，filter（条件） #2.实现删除方法，delete（） Student.objects.filter(id=9).delete() return HttpResponse(&apos;删除学生成功&apos;) 实现更新数据1234567891011def up_stu(request): #实现更新 #1.获取更新的数据 ， filter（条件） #2.实现更新方法，update（） #第一种方法 # Student.objects.filter(id=2).update(s_name=&apos;小追&apos;) #第二种方法 stu = Student.objects.filter(id=2).first() stu.s_name = &apos;妲己&apos; stu.save() return HttpResponse(&apos;更新成功&apos;) 实现查询数据123456789101112131415161718192021222324252627282930313233def sel_stu(requset): #查询学生信息 #查询所有学生信息 all（） # stus = Student.objects.all() for stu in stus: print(stu.s_name) #查询id=2的学生信息，filter（） stu = Student.objects.filter(id=2).first() print(stu) #1.get(条件)方法，获取唯一的一个对象（条件唯一） #2.get（条件）中的条件必须成立 stu = Student.objects.get(id=2) print(stu) #过滤出不满足条件的信息 stus = Student.objects.filter(s_gender=1) print(stus) #exclude（条件）方法：不包含 stus = Student.objects.exclude(s_gender=0) print(stus) #排序order_by stus = Student.objects.order_by(&apos;-id&apos;) print(stus) #q取出对象中的某个字段 stus = Student.objects.all().values(&apos;s_name&apos;,&apos;s_age&apos;) print(stus) return HttpResponse(&apos;查询所有学生信息&apos;)]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django安装]]></title>
    <url>%2Fpost%2FDjango%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装virtualenv （创建虚拟环境） 首先安装虚拟环境进入cmd的python中1pip install virtualenv 创建虚拟环境12virtualenv --no-site-packages -p python版本路径python.exe djenvdjenv 创建文件的名字 ``` :E:\指定python版本的路径\python.exe12345```--no-site-packages```: 纯净环境###### 激活虚拟环境- windows进入Scripts目录直接执行activate命令 E:\python1808\env\djenv\Scripts&gt;activate1- mac/Linux/Ubuntu进入bin目录：执行source cativate命令 激活效果(路径前有创建的虚拟环境名称)：(djenv) E:\python1808\env\djenv\Scripts&gt; 123456789101112###### 退出虚拟环境 deactivate以下在pycham中的Terminal中运行##### pip的使用首先确认是否在虚拟环境中进行pip --version 检查pip版本更新pip python -m pip install -U pip12345678pip list ：查看安装的库![](https://upload-images.jianshu.io/upload_images/14827759-529d3b36960dcb3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)pip install xxxx ：安装xxxx查看有没有冲突的依赖库 pip check1检查安装了那些三方库和库的版本 pip freeze1将安装过的库重定向到requirement.txt中 pip freeze &gt; requirement.txt12345代码到新环境中只需要```pip install -r requirement.txt```即可安装与之前环境一样的库##### 创建django项目​```django-admin startproject day01 创建应用1.manage.py startapp 应用名（随便）```123456789101112131415161718192021222324252627282930312.在settings.py文件中的INSTALLED_APPS中添加应用的文件名3.在新建的应用文件夹下的models.py文件中创建表格类（相应的数据写在类中）##### MVT模型:M:models.py 模型层 -定义模型和数据库中的表之间的关联关系V:views.py 视图层 -写业务逻辑的地方T：templates 模板 - 定义页面HTML的地方MVT模式是有MVC模式演变而来。MVC模式是所有框架遵循的模式M:模型层V：模板，HEML页面C：controller，控制器，写业务逻辑的地方##### 迁移表格第一次```python manage.py migrate```- 将Ddjango表格迁移到数据库添加或者修改后先```python manage.py makemigrations```- 生成迁移文件再```python manage.py migrate```将修改后的内容迁移到数据库##### 运行项目 python manage.py runserver默认ip 127.0.0.1默认端口 8000 修改ip和端口python manage.py runserver 0.0.0.0:80ip为0.0.0.0 表示任何人可以通过公网ip访问自己django的项目端口port：如果设置为80，表示访问时该端口可以不用写，直接访问公网ip地址单独修改端口 python manage.py runserver 端口号1234567##### 配置Django打开 项目文件夹中的settings.py文件，修改106行语言设置 LANGUAGE_CODE = &apos;zh-hans&apos;修改时区 TIME_ZONE = &apos;Asia/Chongqing&apos;修改数据库连接（打开 hellodjango文件夹中的settings.py文件） #名字大写DATABASES = { ‘default’: { ‘ENGINE’: ‘django.db.backends.mysql’, ‘NAME’: ‘HRS’, #数据库名称（区分大小写） ‘HOST’: ‘localhost’,#本地或者阿里云 ‘PORT’:3306, ‘USER’:’root’, ‘PASSWORD’:’123456’, ‘TIME_ZONE’:’Asia/Chongqing’ #时区设置（必要） } }123###### 连接数据库修改当前目录下 _ _ init _ _ 配置文件添加以下内容 import pymysql #没有pymql的需要安装 pip install pymysql pymysql.install_as_MySQLdb()`]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django框架]]></title>
    <url>%2Fpost%2FDjango%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[以下代码在Terminal中运行更新pip1python -m pip install -U pip pip –version 检查pip版本 安装Django步骤1.PyCharm —&gt;创建hellodjango项目2.在Terminal 的虚拟环境中安装依赖库 —&gt;1pip install django python django-redis djangorestframework pillow 查看有没有冲突的依赖库1pip check 检查安装了那些三方库和库的版本1pip freeze 将安装过的库重定向到requirement.txt中1pip freeze &gt; requirement.txt 3.创建Django项目 startproject hellodiango . ```1``` . 代表当前路径下 4.运行项目123456789python manage.py runserver默认ip 127.0.0.1默认端口 8000修改ip和端口python manage.py runserver 0.0.0.0:80ip为0.0.0.0 表示任何人可以通过公网ip访问自己jango的项目端口port：如果设置为80，表示访问时该端口可以不用写，直接访问公网ip地址单独修改端口 python manage.py runserver 端口号 5. 将安装的依赖库导入到requirements.txt文件中pip freeze &gt; requirements.txt 读取requirements.txt文件中的依赖库并全部直接安装pip install -r requirements.txt 打开 hellodjango文件夹中的settings.py文件，修改106行语言设置 LANGUAGE_CODE = ‘zh-hans’修改时区 TIME_ZONE = ‘Asia/Chongqing’ 修改数据库连接（打开 hellodjango文件夹中的settings.py文件）12345678910111213#名字大写DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;HRS&apos;, &apos;HOST&apos;: &apos;localhost&apos;,#本地或者阿里云 &apos;PORT&apos;:3306, &apos;USER&apos;:&apos;root&apos;, &apos;PASSWORD&apos;:&apos;123456&apos;, &apos;TIME_ZONE&apos;:&apos;Asia/Chongqing&apos; #时区设置（必要） &#125;&#125; 连接数据库修改当前目录下init配置文件添加一下内容123import pymysqlpymysql.install_as_MySQLdb() 迁移Django表格python manage.py migrate 创建超级管理员用户1python manage.py createsuperuser]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2Fpost%2Fredis%2F</url>
    <content type="text"><![CDATA[Redis 命令参考详情Redis 命令参考jobs – 查看后台进程bg %进程编号 – 将后台程序运行起来fg %进程编号 – 将后台程序放在前台运行redis-server &amp; – 直接将程序放在后台运行在前台程序中使用CTRL+Z 将前台程序放在后台 但是是暂停状态 运行则使用bg %进程编号 redis-server –requirepass 123456 –appendonly yes &gt; redis.log 2&gt; redis-error.log &amp;–启动服务器 redis 提供了两种持久化数据的方案：1.RDB - 默认开启2.AOF - 默认关闭 –appendonly yes –requirepass password – 设置密码 –appendonly yes – 配置数据持久化 AOF手动 – port 端口号 – 修改端口 kv储存系统 - REmote DIctionary Server 提供高速缓存服务 - 缓存热点数据（访问量大数据量不大） 缓解数据库压力（高频访问数据不用直接访问数据库） redis-cli -h 120.77.87.226 -p 6379 连接redisauth 密码 - 验证身份ping - 心跳事件set 舰队对-添加键值对get 键 - 查看键对应的值expire 键 时间（秒） – 设置超时时间ttl 键 - 查看剩余时间del 键 –删除键值对keys - 查看键值对 exists key [key …] -判断键是否存在 1存在 0 不存在flushdb-清空当前数据库的键值对flushall - 清除所有数据库中的所有键值对 select index 切换数据库 最多16个dbsize - 查看键值对的数量 save / bgsave - 保存数据 / 后台保存数据shutdown - 关闭服务器quit 退出 主人：redis-server –requirepass 123123 &gt; redis.log 2&gt; redis-error.log &amp; 奴隶：edis-server –slaveof 主人ip 端口 –masterauth 密码 &gt; redis.log 2&gt; redis-error.log &amp; slaveof ip 端口号masterauth 密码 退出奴隶：slaveof no one 经典数据储存结构 栈（stack） - FILO - 先进后出 - lpush+lpop / rpush+rpop 递归求阶乘: 1234567def f(num): if num in (0,1): return 1 return num*f(num-1) 队列（queue） - FIFO - 先进先出 - lpush +rpop /rpush+lpop 集合： sadd 添加集合smember 查看集合元素sinter 交集sunion 并集sdiff 差集sismember 判断元素是否在集合中scard 集合中元素的个数srandmember 随机取集合中的元素]]></content>
      <categories>
        <category>Redis数据库</category>
      </categories>
      <tags>
        <tag>命令参考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库查询]]></title>
    <url>%2Fpost%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[– 创建SRS数据库12drop database if exists SRS;create database SRS default charset utf8 collate utf8_bin; – 切换到SRS数据库1use SRS; – 创建学院表12345678create table tb_college(collid int not null auto_increment comment &apos;学院编号&apos;,collname varchar(50) not null comment &apos;学院名称&apos;,collmaster varchar(20) not null comment &apos;院长姓名&apos;,collweb varchar(511) default &apos;&apos; comment &apos;学院网站&apos;,primary key (collid)); – 添加唯一约束1alter table tb_college add constraint uni_college_collname unique (collname); – 创建学生表12345678910create table tb_student(stuid int not null comment &apos;学号&apos;,sname varchar(20) not null comment &apos;学生姓名&apos;,gender bit default 1 comment &apos;性别&apos;,birth date not null comment &apos;出生日期&apos;,addr varchar(255) default &apos;&apos; comment &apos;籍贯&apos;,collid int not null comment &apos;所属学院编号&apos;,primary key (stuid)); – 检查约束(mysql不支持)1alter TABLE tb_student add constraint ck_student_birth check (brith between &apos;1990-1-1&apos; and &apos;1999-12-31&apos;); – 添加外键约束1alter table tb_student add constraint fk_student_collid foreign key (collid) references tb_college (collid); – 创建教师表1234567create table tb_teacher(teaid int not null comment &apos;教师工号&apos;,tname varchar(20) not null comment &apos;教师姓名&apos;,title varchar(10) default &apos;&apos; comment &apos;职称&apos;,collid int not null comment &apos;所属学院编号&apos;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227-- 添加主键约束alter table tb_teacher add constraint pk_teacher primary key (teaid);-- 添加外键约束alter table tb_teacher add constraint fk_teacher_collid foreign key (collid) references tb_college (collid);-- 创建课程表create table tb_course(couid int not null comment &apos;课程编号&apos;,cname varchar(50) not null comment &apos;课程名称&apos;,credit tinyint not null comment &apos;学分&apos;,teaid int not null comment &apos;教师工号&apos;,primary key (couid));-- 添加外键约束alter table tb_course add constraint fk_course_tid foreign key (teaid) references tb_teacher (teaid);-- 创建学生选课表create table tb_score(scid int not null auto_increment comment &apos;选课编号&apos;,sid int not null comment &apos;学号&apos;,cid int not null comment &apos;课程编号&apos;,seldate date comment &apos;选课时间日期&apos;,mark decimal(4,1) comment &apos;考试成绩&apos;,primary key (scid));-- 添加外键约束alter table tb_score add constraint fk_score_sid foreign key (sid) references tb_student (stuid);alter table tb_score add constraint fk_score_cid foreign key (cid) references tb_course (couid);-- 添加唯一约束alter table tb_score add constraint uni_score_sid_cid unique (sid, cid);-- 插入学院数据insert into tb_college (collname, collmaster, collweb) values (&apos;计算机学院&apos;, &apos;左冷禅&apos;, &apos;http://www.abc.com&apos;),(&apos;外国语学院&apos;, &apos;岳不群&apos;, &apos;http://www.xyz.com&apos;),(&apos;经济管理学院&apos;, &apos;风清扬&apos;, &apos;http://www.foo.com&apos;);-- 插入学生数据insert into tb_student (stuid, sname, gender, birth, addr, collid) values(1001, &apos;杨逍&apos;, 1, &apos;1990-3-4&apos;, &apos;四川成都&apos;, 1),(1002, &apos;任我行&apos;, 1, &apos;1992-2-2&apos;, &apos;湖南长沙&apos;, 1),(1033, &apos;王语嫣&apos;, 0, &apos;1989-12-3&apos;, &apos;四川成都&apos;, 1),(1572, &apos;岳不群&apos;, 1, &apos;1993-7-19&apos;, &apos;陕西咸阳&apos;, 1),(1378, &apos;纪嫣然&apos;, 0, &apos;1995-8-12&apos;, &apos;四川绵阳&apos;, 1),(1954, &apos;林平之&apos;, 1, &apos;1994-9-20&apos;, &apos;福建莆田&apos;, 1),(2035, &apos;东方不败&apos;, 1, &apos;1988-6-30&apos;, null, 2),(3011, &apos;林震南&apos;, 1, &apos;1985-12-12&apos;, &apos;福建莆田&apos;, 3),(3755, &apos;项少龙&apos;, 1, &apos;1993-1-25&apos;, null, 3),(3923, &apos;杨不悔&apos;, 0, &apos;1985-4-17&apos;, &apos;四川成都&apos;, 3);-- 插入老师数据insert into tb_teacher (teaid, tname, title, collid) values (1122, &apos;张三丰&apos;, &apos;教授&apos;, 1),(1133, &apos;宋远桥&apos;, &apos;副教授&apos;, 1),(1144, &apos;杨逍&apos;, &apos;副教授&apos;, 1),(2255, &apos;范遥&apos;, &apos;副教授&apos;, 2),(3366, &apos;韦一笑&apos;, &apos;讲师&apos;, 3);-- 插入课程数据insert into tb_course (couid, cname, credit, teaid) values (1111, &apos;Python程序设计&apos;, 3, 1122),(2222, &apos;Web前端开发&apos;, 2, 1122),(3333, &apos;操作系统&apos;, 4, 1122),(4444, &apos;计算机网络&apos;, 2, 1133),(5555, &apos;编译原理&apos;, 4, 1144),(6666, &apos;算法和数据结构&apos;, 3, 1144),(7777, &apos;经贸法语&apos;, 3, 2255),(8888, &apos;成本会计&apos;, 2, 3366),(9999, &apos;审计学&apos;, 3, 3366);-- 插入选课数据insert into tb_score (sid, cid, seldate, mark) values (1001, 1111, &apos;2017-09-01&apos;, 95),(1001, 2222, &apos;2017-09-01&apos;, 87.5),(1001, 3333, &apos;2017-09-01&apos;, 100),(1001, 4444, &apos;2018-09-03&apos;, null),(1001, 6666, &apos;2017-09-02&apos;, 100),(1002, 1111, &apos;2017-09-03&apos;, 65),(1002, 5555, &apos;2017-09-01&apos;, 42),(1033, 1111, &apos;2017-09-03&apos;, 92.5),(1033, 4444, &apos;2017-09-01&apos;, 78),(1033, 5555, &apos;2017-09-01&apos;, 82.5),(1572, 1111, &apos;2017-09-02&apos;, 78),(1378, 1111, &apos;2017-09-05&apos;, 82),(1378, 7777, &apos;2017-09-02&apos;, 65.5),(2035, 7777, &apos;2018-09-03&apos;, 88),(2035, 9999, date(now()), null),(3755, 1111, date(now()), null),(3755, 8888, date(now()), null),(3755, 9999, &apos;2017-09-01&apos;, 92);-- 查询所有学生信息select * from tb_student;-- 查询所有课程名称及学分(投影和别名)select cname as 课程名称, credit as 学分 FROM tb_course;-- 查询所有女学生的姓名和出生日期(筛选)select sname as 姓名,birth as 生日 from tb_student where gender=0;-- 查询所有80后学生的姓名、性别和出生日期(筛选)select sname as 姓名,case gender when 1 then &apos;男&apos; when 2 then &apos;未知&apos; else &apos;女&apos; end as 性别,birth as 生日 from tb_student where birth between &apos;1980-1-1&apos; and &apos;1989-12-31&apos;;-- 方法二（使用mysql分之函数）SELECT sname AS 姓名, if( gender,&apos;男&apos; ,&apos;女&apos;) AS 性别, birth AS 生日 FROM tb_student WHERE birth BETWEEN &apos;1980-1-1&apos; AND &apos;1989-12-31&apos;; -- 查询名字4个字的学生姓名和学号select stuid as 学号,sname as 姓名 from tb_student where LENGTH(sname)/3=4;-- 查询姓”杨“的学生姓名和性别(模糊)select sname as 姓名, if(gender,&apos;男&apos;,&apos;女&apos;) as 性别 from tb_student where sname like &apos;杨%&apos;; -- 百分号匹配任意个数 字符-- 查询姓”杨“名字两个字的学生姓名和性别(模糊)select sname as 姓名, if(gender,&apos;男&apos;,&apos;女&apos;) as 性别 from tb_student where sname like &apos;杨_&apos;; -- 下划线匹配一个字符-- 查询姓”杨“名字三个字的学生姓名和性别(模糊)select sname as 姓名, if(gender,&apos;男&apos;,&apos;女&apos;) as 性别 from tb_student where sname like &apos;杨__&apos;;-- 查询名字中有”不“字或“嫣”字的学生的姓名(模糊)select sname as 姓名, if(gender,&apos;男&apos;,&apos;女&apos;) as 性别 from tb_student where sname like &apos;%不%&apos; or sname like &apos;%嫣%&apos;;-- 查询没有录入家庭住址的学生姓名(空值)select sname as 姓名 from tb_student where addr is null or addr=&apos;&apos;;-- 查询录入了家庭住址的学生姓名(空值)select sname as 姓名 from tb_student where addr is not null and addr &lt;&gt;&apos;&apos;;-- 查询学生选课的所有日期(去重)select distinct seldate from tb_score; -- 去重-- 查询学生的家庭住址(去重)select distinct addr from tb_student where addr is not null and addr&lt;&gt;&apos;&apos;; -- 查询男学生的姓名和生日按年龄从大到小排列(排序)-- 升序 asc（默认）/ 降序 descselect sname as 姓名, year(now()) - year(birth) as 年龄 from tb_student where gender=1 ORDER BY birth;select sname as 姓名, year(now()) - year(birth) as 年龄 from tb_student where gender=1 ORDER BY birth desc;select stuid, sname as 姓名,gender as 性别 from tb_student order by gender asc,stuid desc;-- 聚合函数： max / min / sum / count /avg-- 查询所有学生select count(*) from tb_student;-- 查询年龄最大的学生的出生日期(聚合函数)select max(birth) from tb_student;-- 查询年龄最小的学生的出生日期(聚合函数)select min(birth) from tb_student;-- 查询男女学生的人数(分组和聚合函数)select if(gender,&apos;男&apos;,&apos;女&apos;) as 性别,count(gender) as 人数 from tb_student group by gender; -- 查询课程编号为1111的课程的平均成绩(筛选和聚合函数)select avg(mark) as 平均成绩 from tb_score where cid=1111;-- 查询学号为1001的学生所有课程的平均分(筛选和聚合函数)select avg(mark) as 平均成绩 from tb_score where sid=1001;-- 查询每个学生的学号和平均成绩(分组和聚合函数)select sid as 学号, avg(mark) as 平均分 from tb_score group by sid;-- 查询平均成绩大于等于90分的且学号在1000到2000之间的学生的学号和平均成绩-- 总结分组前的筛选用 where;分组后的筛选用 havingselect sid as 学号, avg(mark) as 平均分 from tb_score where sid between 1000 and 3999 group by sid having 平均分&gt;=90 order by 平均分 desc;-- 查询年龄最大的学生的姓名(子查询)-- 把一个查询的结果当成另一个查询的一部分来使用select sname as 姓名 from tb_studentwhere birth=(select min(birth) from tb_student);-- 查询年龄最大的学生姓名和年龄(子查询+运算)select sname as 姓名,year(now())-year(birth) as 年龄 from tb_studentwhere birth=(select min(birth) from tb_student);-- 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)select sname as 姓名 from tb_studentwhere stuid in (select sid from tb_score group by sid having count(sid)&gt;2);-- 查询学生姓名、课程名称以及成绩(连接查询)select sname as 姓名 ,cname as 课程, mark as 分数from tb_student,tb_course,tb_scorewhere stuid=sid and couid=cid;-- 查询选课学生的姓名和平均成绩(子查询和连接查询)select sname as 姓名,avgmark as 平均分 from tb_student t1,(select sid ,avg(mark) as avgmark from tb_score group by sid) t2where stuid=sid;-- 内连接 表1 inner join 表2 on 连表条件select sname as 姓名,avgmark as 平均分 from tb_student t1 inner join(select sid ,avg(mark) as avgmark from tb_score group by sid) t2on stuid=sid;-- 查询每个学生的姓名和选课数量(左外连接和子查询)select sname as 姓名 , IFNULL(total,0) as 选课数量 from tb_student t1 left outer JOIN(select sid ,count(sid) as total from tb_score GROUP BY sid) t2on stuid=sid ;-- 总结 左外连接 - 将左表不满足连表条件的记录也要查上来，不满足连表条件的缺失的地方补空值20636-- 右外连接 - 将右表不满足连表条件的记录也要查上来，不满足连表条件的缺失的地方补空值-- 在连接多表查询的时候，写在前面的表成为左表，写在后面的表为右表-- 左外连接 left outer join / 右外连接 right outer join -- mysql 不支持全外连接 full outer join-- ifnull()函数 将缺失的地方以特定值补上]]></content>
  </entry>
  <entry>
    <title><![CDATA[参考资料及一些好用的网站]]></title>
    <url>%2Fpost%2F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[redis数据库命令学习 模拟分析Python执行过程 python题库:领扣 前端框架 虚拟接口网站 虚拟接口用法 玩转Linux操作系统 数据库问题查找解决方法]]></content>
      <categories>
        <category>参考资料</category>
      </categories>
      <tags>
        <tag>参考资料</tag>
        <tag>好用的网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2Fpost%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[数据库 - 实现项目中的数据持久化数据库的类别1.关系型数据库 - MySQL 特点：1.理论基础：集合论和关系代数；2.用二维表来组织数据（行（记录），列（字段））；3.SQL - 结构化查询语言4.可以保证数据的完整性： -实体完整性：每条记录都是独一无二的，没有冗余（重复）- 主键/唯一索引 -参照完整性（引用完整性）：外键 -域完整性：数据类型，非空约束，默认值约束，检查约束 关系型数据库产品：1.Oracle - 甲骨文2.MySQL - 甲骨文 - MariaDB（开源）3.DB2、SQLserver、PostgreSQL、SQLite 2.NoSQL数据库 - Redis1.MongoDB - 文档数据库 - 适合量大但价值低的数据2.Redis - KV数据库 - 性能好，适合做高速缓存服务3.ElasticSearch - 搜索引擎 Linux安装软件1.包管理工具 - yum/ rpm Docker - 提供虚拟化服务，创建虚拟化容器并安装软件12345安装命令：yum -y install docker-io删除命令：yum -y remove docker-io查看信息：yum info查询：yum search查看是否安装：yum list installed | grep docker 启动Docker服务123456开启命令：systemctl start docker关闭：systemctl stop docker重启：systemctl restart docker查看状态：systemctl status docker开机自启：systemctl enable docker禁用开机自启：systemctl disable docker 使用Docker命令1. 查看已经下载的镜像文件（安装包）：docker images 2.下载MySQL的镜像文件：docker pull mysql：5.7 MySQL数据库超级管理员账号 - rootOracle数据库超级管理员账号 - sysSQLServer数据库超级管理员账号 - sa 3.创建并允许容器docker run -d -p 3306:3306 --name mysql57 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 4.查看运行中的容器docker ps 安装MySQ客户端工具：Navicat for MySQL -猫SQLyog - 海豚Toad for MySQL - 蛤蟆 5.查看所有的容器docker container ls -a 6.启动docker start mysql57 7.停止docker stop mysql57 8.删除容器docker rm -f mysql57 MySQL语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146 -- SQL(结构化查询语言)分为三组 -- 1.DDL （数据定义语言）：create（创建） / drop（删除） /alter（修改） -- 2.DML（数据操作语言）“insert（插入）/ delete（删除）/update（更新）/select（查询数据） -- 3.DCL（数据控制语言）：grant(授权)/ revoke() /commit() / rollback() -- 创建数据库srs（学生选课系统） CREATE DATABASE srs DEFAULT charset utf8; -- 切换到srs数据库 use srs; -- 创建二维表来承载数据 -- 创建学生表tb_student -- 在学生表中学号可以唯一的标记一条学生记录 -- 我们通常称这样的列为主键列 CREATE TABLE tb_student ( stuid INT NOT NULL COMMENT &apos;学号&apos;, -- 非空约束 stuname VARCHAR(10) NOT NULL COMMENT &apos;姓名&apos;, -- 变长字符串最大长度10 stusex bit DEFAULT 1 COMMENT &apos;性别&apos;, -- 默认是1 stubirth date COMMENT &apos;出生日期&apos;, stuaddr VARCHAR(255) COMMENT &apos;家庭住址&apos;, PRIMARY KEY (stuid) ); -- 修改学生表添加联系方式 ALTER TABLE tb_student add COLUMN stutel char(11); -- 修改学生表删除联系方式 ALTER TABLE tb_student DROP COLUMN stutel; -- 向学生表插入数据 INSERT INTO tb_student VALUES (1001,&apos;小花&apos;,1,&apos;1999-9-9&apos;,&apos;四川成都&apos;); INSERT INTO tb_student (stuid,stuname) VALUES (1002,&apos;小猪&apos;); INSERT INTO tb_student VALUES (1003,&apos;小小&apos;,0,&apos;1998-2-2&apos;,null), (1004,&apos;小邻&apos;,0,null,null), (1005,&apos;小红&apos;,0,null,&apos;四川成都&apos;); -- 截断表 TRUNCATE TABLE tb_student; -- 删除表格数据 delete from tb_student WHERE stuid=1002; -- 删除学号1003-1005之间的学生信息 DELETE FROM tb_student WHERE stuid&gt;=1003 AND stuid&lt;=1005; DELETE FROM tb_student WHERE stuid IN (1003,1004,1005); DELETE FROM tb_student WHERE stuid BETWEEN 1003 AND 1005; -- 更新学号为1002 和1004学生的生日 UPDATE tb_student SET stubirth=&apos;1990-1-1&apos; WHERE stuid=1002 OR stuid=1004; -- 更新学号1002的姓名，性别，住址 UPDATE tb_student SET stuname=&apos;王小梅&apos;,stusex=0,stuaddr=&apos;重庆&apos; WHERE stuid=1002; -- 更新住址为空值的添加住址 -- 判断是否为空 is / is not UPDATE tb_student SET stuaddr=&apos;四川绵阳&apos; WHERE stuaddr is null; -- 查询 -- 筛选 SELECT * FROM tb_student; -- 加了where叫筛选 SELECT * FROM tb_student WHERE stusex=0; -- 投影 SELECT stuname,stubirth FROM tb_student WHERE stusex=1; -- 创建学院表 tb_college CREATE TABLE tb_college (collname VARCHAR(10) not null COMMENT &apos;学院名&apos;,collid INT auto_increment not null COMMENT &apos;学院编号&apos;, -- auto_increment自动编号 自增字段website VARCHAR(255) COMMENT &apos;学院网址&apos;, -- unique 唯一性约束PRIMARY KEY (collid));--修改tb_college 给weibsite添加唯一性约束条件alter TABLE tb_college add CONSTRAINT nui_college_website unique (website);--修改tb_college 添加主键约束条件-- ALTER TABLE tb_college add CONSTRAINT pk_college_id PRIMARY KEY (collid);-- 修改tb_college 删除名为nui_college_website的唯一性约束ALTER TABLE tb_college drop INDEX nui_college_website;-- 向学院表插入3条记录INSERT into tb_college (collname,website) VALUES(&apos;计算机学院&apos;,&apos;heep://www.aaa.com&apos;),(&apos;外国语学院&apos;,&apos;heep://www.bbb.com&apos;),(&apos;经济管理学院&apos;,&apos;heep://www.ccc.com&apos;);-- 查询所有信息SELECT * FROM tb_college;-- 修改tb_student 添加新列表示学生在哪个学院ALTER TABLE tb_student add COLUMN collid int COMMENT &apos;所在学院编号&apos;;-- 修改tb_student添加一个外键约束,限制学生表中学院编号必须参照学院表的学院编号alter table tb_student add constraint fk_student_collid foreign key (collid) references tb_college (collid); -- references 参照 foreign key 外键-- 总结 ：如果要维持两个实体（表）之间一对多或多对一的关系-- 需要在多的一方添加一个外键列建立起参照完整性即可drop TABLE tb_teacher;-- 创建老师表 编号，名字 职称 所属学院create table tb_teacher(teacid int auto_increment comment &apos;编号&apos;,teacname varchar(10) not null comment &apos;姓名&apos;,teacpost varchar(10) not null comment &apos;职称&apos;,teaccoll int comment &apos;学院&apos;, -- 添加外键约束 references tb_college (collid)primary key (teacid),foreign key (teaccoll) references tb_college (collid) -- 添加外键约束);-- 添加外键约束 老师所属学院参照学院表编号alter table tb_teacher add constraint fk_teacher_collidforeign key (teaccoll) references tb_college (collid)；-- 创建课程表tb_course,编号，名字，学分CREATE table tb_course(courid int auto_increment COMMENT &apos;编号&apos;,courname VARCHAR(50) not null COMMENT &apos;名字&apos;,credit tinyint not null COMMENT &apos;学分&apos;,primary key (courid));-- 修改课程表添加外键列并设置外键约束alter TABLE tb_course add column teacid int comment &apos;授课老师编号&apos;;alter table tb_course add constraint dk_course_teacidforeign key (teacid) references tb_teacher (teacid);-- 多对多关系需要创建中间表来维持create table tb_score(scid int auto_increment comment &apos;选课编号&apos;,sid int not null comment &apos;学生学号&apos;,cid int not null comment &apos;课程编号&apos;,mark decimal (4,1) comment &apos;考试成绩&apos;,primary key (scid),foreign key (sid) references tb_student (stuid),foreign key (cid) references tb_course (courid));-- 将cid和sid添加唯一性约束alter table tb_score add constraint uni_score_sid_cid unique (sid,cid);]]></content>
      <tags>
        <tag>数据库介绍</tag>
        <tag>MySQL语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx服务器]]></title>
    <url>%2Fpost%2FNginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Nginx服务器1.阿里云添加80端口阿里云上默认只有一个22端口用来做远程登录，如果希望在阿里云上安装支持http请求的nginx服务器，需要给阿里云添加80端口 2. 安装nginxa) 添加nginx存储库 1yum install epel-release b) 安装nginx 1yum install nginx c) 运行nginxNginx不会自行启动。要运行Nginx 1systemctl start nginx nginx的运行命令: 12systemctl status nginx 查看nginx的状态 systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动 d) 系统启动时启动Nginx 1systemctl enable nginx e）如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信： 12345sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload 3.nginx目录共享配置a) 在contOS目录中确定一个需要共享的文件夹，例如： /home/yutingb) 打开 etc/nginx/nginx.conf 文件，设置server 1234567#共享设置 - 在浏览器中输入服务器ip地址，会展示共享目录的文件列表root /home/yuting;location / &#123; autoindex on; autoindex_exact_size on; autoindex_localtime on;&#125; 除了可以共享文件，还可以自定义页面 12345#自定义服务器页面location / &#123; root /home/yuting; index index.html index.htm;&#125; 注意： 如果出现权限问题，可以修改目录的权限 ssh密钥认证1.在主机和从机上执行：ssh-keygen 2.在从机上执行: scp id_rsa.pub root@主机地址:~/.ssh/master.pub(上面这条指令是将从机上的 id_rsa.pub文件拷贝传递给到主机的.ssh文件夹下，并且命名为’master.pub’) 3.在主机中的.ssh文件夹中创建authorized_keys文件： touch authorized_keys 4.修改文件authorized_keys的权限: chmod 600 authorized_keys 5.将master.pub放进authorized_keys文件中: cat master.pub &gt;&gt; authorized_keys 6.在操作主机的时候，需要主机能够自己免密访问自己就将自己的公钥放在自己的authorized_keys文件中]]></content>
  </entry>
</search>
